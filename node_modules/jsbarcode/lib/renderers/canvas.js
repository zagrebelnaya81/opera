"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _shared = require("./shared.js");

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function renderer(canvas, encodings, options) {
  // Abort if the browser does not support HTML5 canvas
  if (!canvas.getContext) {
    throw new Error('The browser does not support canvas');
  }

  var ctx = canvas.getContext('2d');
  prepareCanvas();

  for (var i = 0; i < encodings.length; i++) {
    var encodingOptions = _objectSpread({}, options, encodings[i].options);

    drawCanvasBarcode(encodingOptions, encodings[i]);
    drawCanvasText(encodingOptions, encodings[i]);
    moveCanvasDrawing(encodings[i]);
  }

  ctx.restore();

  function prepareCanvas() {
    ctx.save();
    (0, _shared.calculateEncodingAttributes)(encodings, options, ctx);
    var totalWidth = (0, _shared.getTotalWidthOfEncodings)(encodings);
    var maxHeight = (0, _shared.getMaximumHeightOfEncodings)(encodings);
    canvas.width = totalWidth + options.marginLeft + options.marginRight;
    canvas.height = maxHeight; // Paint the canvas

    ctx.clearRect(0, 0, canvas.width, canvas.height);

    if (options.background) {
      ctx.fillStyle = options.background;
      ctx.fillRect(0, 0, canvas.width, canvas.height);
    }

    ctx.translate(options.marginLeft, 0);
  }

  function drawCanvasBarcode(options, encoding) {
    var binary = encoding.data; // Creates the barcode out of the encoded binary

    var yFrom;

    if (options.textPosition == 'top') {
      yFrom = options.marginTop + options.fontSize + options.textMargin;
    } else {
      yFrom = options.marginTop;
    }

    ctx.fillStyle = options.lineColor;

    for (var b = 0; b < binary.length; b++) {
      var x = b * options.width + encoding.barcodePadding;

      if (binary[b] === '1') {
        ctx.fillRect(x, yFrom, options.width, options.height);
      } else if (binary[b]) {
        ctx.fillRect(x, yFrom, options.width, options.height * binary[b]);
      }
    }
  }

  function drawCanvasText(options, encoding) {
    var font = options.fontOptions + ' ' + options.fontSize + 'px ' + options.font; // Draw the text if displayValue is set

    if (options.displayValue) {
      var x, y;

      if (options.textPosition == 'top') {
        y = options.marginTop + options.fontSize - options.textMargin;
      } else {
        y = options.height + options.textMargin + options.marginTop + options.fontSize;
      }

      ctx.font = font; // Draw the text in the correct X depending on the textAlign option

      if (options.textAlign == 'left' || encoding.barcodePadding > 0) {
        x = 0;
        ctx.textAlign = 'left';
      } else if (options.textAlign == 'right') {
        x = encoding.width - 1;
        ctx.textAlign = 'right';
      } // In all other cases, center the text
      else {
          x = encoding.width / 2;
          ctx.textAlign = 'center';
        }

      ctx.fillText(encoding.text, x, y);
    }
  }

  function moveCanvasDrawing(encoding) {
    ctx.translate(encoding.width, 0);
  }
}

var _default = renderer;
exports.default = _default;
//# sourceMappingURL=canvas.js.map