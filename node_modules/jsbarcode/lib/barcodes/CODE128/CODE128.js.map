{"version":3,"sources":["../../../src/barcodes/CODE128/CODE128.js"],"names":["CODE128","data","options","substring","bytes","split","map","char","charCodeAt","test","startIndex","shift","startSet","SET_BY_CODE","undefined","RangeError","shouldEncodeAsEan128","unshift","FNC1","encodingResult","next","text","replace","getBar","result","checksum","MODULO","STOP","isEAN128","ean128","toLowerCase","index","BARS","toString","set","SET_A","charCode","SET_B","pos","length","nextCode","nextSet","SWAP","SHIFT","correctIndex","enc","weight","Barcode"],"mappings":"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","sourcesContent":["import Barcode from '../Barcode.js';\nimport { SHIFT, SET_A, SET_B, MODULO, STOP, FNC1, SET_BY_CODE, SWAP, BARS } from './constants';\n\n// This is the master class,\n// it does require the start code to be included in the string\nclass CODE128 extends Barcode {\n\tconstructor(data, options) {\n\t\tsuper(data.substring(1), options);\n\n\t\t// Get array of ascii codes from data\n\t\tthis.bytes = data.split('').map(char => char.charCodeAt(0));\n\t}\n\n\tvalid() {\n\t\t// ASCII value ranges 0-127, 200-211\n\t\treturn /^[\\x00-\\x7F\\xC8-\\xD3]+$/.test(this.data);\n\t}\n\n\t// The public encoding function\n\tencode() {\n\t\tconst bytes = this.bytes;\n\t\t// Remove the start code from the bytes and set its index\n\t\tconst startIndex = bytes.shift() - 105;\n\t\t// Get start set by index\n\t\tconst startSet = SET_BY_CODE[startIndex];\n\n\t\tif (startSet === undefined) {\n\t\t\tthrow new RangeError('The encoding does not start with a start character.');\n\t\t}\n\n\t\tif (this.shouldEncodeAsEan128() === true) {\n\t\t\tbytes.unshift(FNC1);\n\t\t}\n\n\t\t// Start encode with the right type\n\t\tconst encodingResult = CODE128.next(bytes, 1, startSet);\n\n\t\treturn {\n\t\t\ttext: this.text === this.data ? this.text.replace(/[^\\x20-\\x7E]/g, '') : this.text,\n\t\t\tdata:\n\t\t\t\t// Add the start bits\n\t\t\t\tCODE128.getBar(startIndex) +\n\t\t\t\t// Add the encoded bits\n\t\t\t\tencodingResult.result +\n\t\t\t\t// Add the checksum\n\t\t\t\tCODE128.getBar((encodingResult.checksum + startIndex) % MODULO) +\n\t\t\t\t// Add the end bits\n\t\t\t\tCODE128.getBar(STOP)\n\t\t};\n\t}\n\n\t// GS1-128/EAN-128\n\tshouldEncodeAsEan128() {\n\t\tlet isEAN128 = this.options.ean128 || false;\n\t\tif (typeof isEAN128 === 'string') {\n\t\t\tisEAN128 = isEAN128.toLowerCase() === 'true';\n\t\t}\n\t\treturn isEAN128;\n\t}\n\n\t// Get a bar symbol by index\n\tstatic getBar(index) {\n\t\treturn BARS[index] ? BARS[index].toString() : '';\n\t}\n\n\t// Correct an index by a set and shift it from the bytes array\n\tstatic correctIndex(bytes, set) {\n\t\tif (set === SET_A) {\n\t\t\tconst charCode = bytes.shift();\n\t\t\treturn charCode < 32 ? charCode + 64 : charCode - 32;\n\t\t} else if (set === SET_B) {\n\t\t\treturn bytes.shift() - 32;\n\t\t} else {\n\t\t\treturn (bytes.shift() - 48) * 10 + bytes.shift() - 48;\n\t\t}\n\t}\n\n\tstatic next(bytes, pos, set) {\n\t\tif (!bytes.length) {\n\t\t\treturn { result: '', checksum: 0 };\n\t\t}\n\n\t\tlet nextCode, index;\n\n\t\t// Special characters\n\t\tif (bytes[0] >= 200) {\n\t\t\tindex = bytes.shift() - 105;\n\t\t\tconst nextSet = SWAP[index];\n\n\t\t\t// Swap to other set\n\t\t\tif (nextSet !== undefined) {\n\t\t\t\tnextCode = CODE128.next(bytes, pos + 1, nextSet);\n\t\t\t}\n\t\t\t// Continue on current set but encode a special character\n\t\t\telse {\n\t\t\t\t// Shift\n\t\t\t\tif ((set === SET_A || set === SET_B) && index === SHIFT) {\n\t\t\t\t\t// Convert the next character so that is encoded correctly\n\t\t\t\t\tbytes[0] =\n\t\t\t\t\t\tset === SET_A ? (bytes[0] > 95 ? bytes[0] - 96 : bytes[0]) : bytes[0] < 32 ? bytes[0] + 96 : bytes[0];\n\t\t\t\t}\n\t\t\t\tnextCode = CODE128.next(bytes, pos + 1, set);\n\t\t\t}\n\t\t}\n\t\t// Continue encoding\n\t\telse {\n\t\t\tindex = CODE128.correctIndex(bytes, set);\n\t\t\tnextCode = CODE128.next(bytes, pos + 1, set);\n\t\t}\n\n\t\t// Get the correct binary encoding and calculate the weight\n\t\tconst enc = CODE128.getBar(index);\n\t\tconst weight = index * pos;\n\n\t\treturn {\n\t\t\tresult: enc + nextCode.result,\n\t\t\tchecksum: weight + nextCode.checksum\n\t\t};\n\t}\n}\n\nexport default CODE128;\n"],"file":"CODE128.js"}